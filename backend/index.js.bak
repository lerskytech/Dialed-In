require('dotenv').config();
const express = require('express');
const cors = require('cors');
const { searchPlaces } = require('./placesService');
const database = require('./database');
const { authRouter, authenticateToken } = require('./auth');
const { createCheckoutSession, handleWebhookEvent } = require('./stripe');
const { loadLocations, clearLocations, searchLocations } = require('./locations');


// Fail-fast environment variable validation
const requiredEnvVars = ['JWT_SECRET', 'STRIPE_SECRET_KEY', 'STRIPE_PRICE_ID', 'STRIPE_WEBHOOK_SECRET'];
for (const envVar of requiredEnvVars) {
  if (!process.env[envVar]) {
    console.error(`❌ Missing required environment variable: ${envVar}. Please add it to the .env file.`);
    process.exit(1);
  }
}

const app = express();
const PORT = process.env.PORT || 3001;

app.post('/api/stripe/webhook', express.raw({ type: 'application/json' }), handleWebhookEvent);

app.use(express.json());


// Authentication routes
app.use('/api/auth', authRouter);


// Stripe checkout session creation
app.post('/api/stripe/create-checkout-session', authenticateToken, async (req, res) => {
    try {
        const session = await createCheckoutSession(req.user.id, req.user.email);
        res.json({ url: session.url });
    } catch (error) {
        console.error('Failed to create checkout session:', error);
        res.status(500).json({ error: 'Failed to create checkout session' });
    }
});

// User-specific routes
app.get('/api/user', authenticateToken, (req, res) => {
  database.db.get('SELECT id, email, subscription_tier, api_usage, monthly_limit, api_key FROM users WHERE id = ?', [req.user.id], (err, user) => {
    if (err) {
      return res.status(500).json({ error: 'Database error' });
    }
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    res.json(user);
  });
});

app.put('/api/user/api-key', authenticateToken, (req, res) => {
  const { apiKey } = req.body;
  if (!apiKey) {
    return res.status(400).json({ error: 'API key is required' });
  }

  database.db.run('UPDATE users SET api_key = ? WHERE id = ?', [apiKey, req.user.id], function(err) {
    if (err) {
      return res.status(500).json({ error: 'Failed to update API key' });
    }
    res.json({ message: 'API key updated successfully' });
  });
});

// API Routes
app.post('/api/search', authenticateToken, async (req, res) => {
  try {
    const { city, category, cities, categories, maxLeads = 25 } = req.body;
    
    const citiesToSearch = cities && cities.length > 0 ? cities : (city ? [city] : []);
    const categoriesToSearch = categories && categories.length > 0 ? categories : (category ? [category] : []);
    
    if (citiesToSearch.length === 0 || categoriesToSearch.length === 0) {
      return res.status(400).json({ error: 'At least one city and one category are required.' });
    }
    
    const user = await new Promise((resolve, reject) => {
      database.db.get('SELECT * FROM users WHERE id = ?', [req.user.id], (err, row) => {
        if (err) reject(err);
        resolve(row);
      });
    });

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    const remainingQuota = user.monthly_limit - user.api_usage;
    if (remainingQuota <= 0) {
      return res.status(429).json({ error: 'Monthly lead generation limit reached. Please upgrade your plan.' });
    }

    let leadsToSearch = Math.min(maxLeads, remainingQuota);

    const contributorName = user.email;

    let apiKeyToUse = user.api_key || process.env.GOOGLE_PLACES_API_KEY;
    if (!apiKeyToUse) {
        return res.status(401).json({ message: 'No API key configured. Please add your Google Places API key in User Settings.' });
    }
    
    const totalCombinations = citiesToSearch.length * categoriesToSearch.length;
    const baseLeadsPerCombo = Math.floor(leadsToSearch / totalCombinations);
    const remainder = leadsToSearch % totalCombinations;
    
    console.log(`🔍 Multi-search: ${citiesToSearch.length} cities × ${categoriesToSearch.length} categories = ${totalCombinations} combinations`);
    console.log(`📊 Distribution: ${baseLeadsPerCombo} leads per combo (${remainder} extra distributed to first combos)`);
    
    let allPlaces = [];
    let comboIndex = 0;
    const searchResults = [];
    
    for (const cityToSearch of citiesToSearch) {
      for (const categoryToSearch of categoriesToSearch) {
        const leadsForThisCombo = baseLeadsPerCombo + (comboIndex < remainder ? 1 : 0);
        if (leadsForThisCombo === 0) continue;

        console.log(`🔍 Searching: ${categoryToSearch} in ${cityToSearch} (${leadsForThisCombo} leads)`);
        const places = await searchPlaces(cityToSearch, categoryToSearch, apiKeyToUse, leadsForThisCombo);
        console.log(`✅ Found ${places.length} real leads for ${categoryToSearch} in ${cityToSearch}`);
        
        const placesWithCityCategory = places.map(place => ({ ...place, city: cityToSearch, category: categoryToSearch }));
        
        allPlaces.push(...placesWithCityCategory);
        searchResults.push({ city: cityToSearch, category: categoryToSearch, requested: leadsForThisCombo, found: places.length });
        
        comboIndex++;
      }
    }
    
    console.log(`📈 Total leads found: ${allPlaces.length} across ${totalCombinations} combinations`);
    
    const stmt = database.db.prepare(`INSERT OR IGNORE INTO leads (name, rating, reviewCount, address, googlePlaceId, city, category, phone, email, website, valueScore, valueTier, contributedBy) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`);
    
    let newLeadsAdded = 0;
    for (const place of allPlaces) {
      const result = stmt.run(place.name, place.rating, place.reviewCount, place.address, place.googlePlaceId, place.city, place.category, place.phone || null, place.email || null, place.website || null, place.valueScore, place.valueTier, contributorName);
      if (result.changes > 0) {
        newLeadsAdded++;
      }
    }
    stmt.finalize();

    if (newLeadsAdded > 0) {
      database.db.run('UPDATE users SET api_usage = api_usage + ? WHERE id = ?', [newLeadsAdded, req.user.id]);
    }
    
    console.log(`🎉 Actually added ${newLeadsAdded} new leads (${allPlaces.length - newLeadsAdded} were duplicates)`);
    res.json({ 
      data: allPlaces,
      newLeads: newLeadsAdded,
      totalFound: allPlaces.length,
      duplicates: allPlaces.length - newLeadsAdded,
      searchSummary: { totalCombinations, citiesToSearch, categoriesToSearch, searchResults }
    });
  } catch (error) {
    console.error('Search error:', error);
    res.status(500).json({ message: error.message });
  }
});

app.get('/api/locations', authenticateToken, async (req, res) => {
  try {
    const { search } = req.query;
    const results = await searchLocations(search);
    res.json(results);
  } catch (error) {
    console.error('Error searching locations:', error);
    res.status(500).json({ error: 'Failed to search location data' });
  }
});

app.get('/api/leads/meta', authenticateToken, async (req, res) => {
  const runQuery = (sql) => {
    return new Promise((resolve, reject) => {
      database.db.all(sql, [], (err, rows) => {
        if (err) return reject(err);
        resolve(rows.map(row => Object.values(row)[0]));
      });
    });
  };

  try {
    const [cities, categories, valueTiers] = await Promise.all([
      runQuery('SELECT DISTINCT city FROM leads WHERE city IS NOT NULL ORDER BY city'),
      runQuery('SELECT DISTINCT category FROM leads WHERE category IS NOT NULL ORDER BY category'),
      runQuery('SELECT DISTINCT valueTier FROM leads WHERE valueTier IS NOT NULL ORDER BY valueTier')
    ]);

    res.json({ cities, categories, valueTiers });
  } catch (error) {
    console.error('Error fetching lead metadata:', error);
    res.status(500).json({ error: 'Failed to fetch lead metadata' });
  }
});

app.get('/api/leads', authenticateToken, (req, res) => {
  const { sortBy = 'createdAt', sortOrder = 'desc', filterCategory, filterValueTier, filterRating, filterCity, filterStatus } = req.query;

  let query = 'SELECT * FROM leads';
  const whereClauses = [];
  const params = [];

  if (filterCategory) {
    whereClauses.push('category = ?');
    params.push(filterCategory);
  }
  if (filterValueTier) {
    whereClauses.push('valueTier = ?');
    params.push(filterValueTier);
  }
  if (filterRating) {
    whereClauses.push('rating >= ?');
    params.push(parseFloat(filterRating));
  }
  if (filterCity) {
    whereClauses.push('city = ?');
    params.push(filterCity);
  }
  if (filterStatus) {
    whereClauses.push('status = ?');
    params.push(filterStatus);
  }

  if (whereClauses.length > 0) {
    query += ' WHERE ' + whereClauses.join(' AND ');
  }

  const validSortColumns = ['name', 'rating', 'valueTier', 'city', 'createdAt'];
  const validSortOrders = ['asc', 'desc'];
  const orderBy = validSortColumns.includes(sortBy) ? sortBy : 'createdAt';
  const orderDirection = validSortOrders.includes(sortOrder.toLowerCase()) ? sortOrder.toUpperCase() : 'DESC';
  
  query += ` ORDER BY ${orderBy} ${orderDirection}`;

  database.db.all(query, params, (err, rows) => {
    if (err) {
      console.error('Database error:', err);
      return res.status(500).json({ error: 'Database error' });
    }
    res.json(rows);
  });
});

app.put('/api/leads/:id/status', authenticateToken, (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;
    
    if (!status || !['called', 'uncalled', 'unanswered'].includes(status)) {
      return res.status(400).json({ error: 'Status must be either "called", "uncalled", or "unanswered"' });
    }
    
    const stmt = database.db.prepare('UPDATE leads SET status = ? WHERE id = ?');
    const result = stmt.run(status, id);
    stmt.finalize();
    
    if (result.changes === 0) {
      return res.status(404).json({ error: 'Lead not found' });
    }
    
    res.json({ message: 'Status updated successfully', id, status });
  } catch (error) {
    console.error('Error updating lead status:', error);
    res.status(500).json({ error: error.message });
  }
});

app.put('/api/leads/:id/notes', authenticateToken, (req, res) => {
  try {
    const { id } = req.params;
    const { notes } = req.body;
    
    const stmt = database.db.prepare('UPDATE leads SET notes = ? WHERE id = ?');
    const result = stmt.run(notes || '', id);
    stmt.finalize();
    
    if (result.changes === 0) {
      return res.status(404).json({ error: 'Lead not found' });
    }
    
    res.json({ message: 'Notes updated successfully', id, notes });
  } catch (error) {
    console.error('Error updating lead notes:', error);
    res.status(500).json({ error: error.message });
  }
});

app.delete('/api/leads/clear', authenticateToken, (req, res) => {
  try {
    const stmt = database.db.prepare('DELETE FROM leads');
    const result = stmt.run();
    stmt.finalize();
    
    console.log(`🗑️ Cleared ${result.changes} leads from database`);
    res.json({ 
      message: `Successfully cleared ${result.changes} leads from database`,
      cleared: result.changes 
    });
  } catch (error) {
    console.error('❌ Error clearing leads:', error);
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/health', (req, res) => {
  res.json({ status: 'OK', timestamp: new Date().toISOString() });
});

async function startServer() {
  try {
    await database.initDb();
    app.listen(PORT, () => {
      console.log(`✅ Server running on http://localhost:${PORT}`);
    });
  } catch (error) {
    console.error('❌ Failed to start server:', error);
    process.exit(1);
  }
}

startServer();

module.exports = app;
